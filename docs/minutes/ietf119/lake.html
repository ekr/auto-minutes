<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>IETF Meeting Minutes</title>
    <link rel="stylesheet" href="/style.css">
  </head>
  <body>
    <header class="site-header">
      <div class="header-content">
        <a href="/">
          <img src="/img/logo.jpg" alt="Logo" width="150" height="150">
        </a>
        <div class="header-text">
          <h1>Automatic IETF Minutes</h1>
          <p class="subtitle">Automatically generated minutes for IETF meetings</p>
        </div>
        <nav class="header-nav">
          <button class="menu-toggle" aria-label="Toggle menu">â˜°</button>
          <ul class="menu">
            <li><a href="/">Home</a></li>
            <li><a href="/about.html">About</a></li>
            <li><a href="https://github.com/ekr/auto-minutes">Source</a></li>
            <li><a href="/license">License</a></li>
          </ul>
        </nav>
      </div>
    </header>
    <main class="main-content">
      <p><a href="lake.txt">Markdown Version</a> | <a href="https://meetecho-player.ietf.org/playout/?session=IETF119-LAKE-20240321-0530">Session Recording</a></p>
<p><strong>Session Date/Time:</strong> 21 Mar 2024 05:30</p>
<h1>lake</h1>
<h2>Summary</h2>
<p>The LAKE working group meeting at IETF 119 covered several topics, including updates on Lightweight Authorization using Ad-hoc (Giovanni), Application Profiles for Ad-hoc (Marco), Remote Attestation of Ad-hoc (Sushan), and PSK-based authentication and rekeying/resumption for Ad-hoc (John). There was also an &quot;if time permits&quot; presentation on a prototype implementation of the disco protocol (Johan).  The working group adoption draft implementation considerations, needed a mail to the list saying yes or against.</p>
<h2>Key Discussion Points</h2>
<ul>
<li><strong>Lightweight Authorization using Ad-hoc (Giovanni):</strong>
<ul>
<li>The voucher can now carry data encrypted between U (device) and W (enrollment server) using an opaque info field.</li>
<li>A new Ad-hoc error code, &quot;access denied,&quot; was defined, along with a reject info field for actionable error information.</li>
<li>Enrollment hints (UHINT, VHINT) were discussed to speed up enrollment with multiple gateways.</li>
<li>Privacy aspects of collecting information about gateways (V1, V2, V3) were raised, requiring further consideration. Need to answer the question: What exactly are we communicating?</li>
<li>Open issues include explaining errors in the V-W interaction (VRS protocol), inverting Ad-hoc roles, and making the opaque info less opaque.</li>
</ul>
</li>
<li><strong>Application Profiles for Ad-hoc (Marco):</strong>
<ul>
<li>Discussion of hybrid exception where a profile identifier can be used, but with additional EAD items. Question of trial and error or needing to specify in the profile.</li>
<li>Consideration of including maximum message size in profiles, and having that be separate for different edit messages.</li>
<li>Consideration of a registry for data and port identifier types, unless one already exists that can be exported for this purpose.</li>
<li>Discussion of transport protocols for Ad-hoc. May need a registry for identifiers.</li>
<li>Presentation of win-on profiles, providing minimal examples.</li>
</ul>
</li>
<li><strong>Remote Attestation of Ad-hoc (Sushan):</strong>
<ul>
<li>Remote attestation procedure using EAD fields in Ad-hoc was defined.</li>
<li>Clarification was sought for the criticality of EADs, specifically regarding the attestation proposal (EAD1) vs. attestation request (EAD2) and evidence (EAD3).</li>
<li>Mohammad raised concerns about the out-of-scope nature of the verifier and how the attestation process would complete without it. The response was the current intent is to define how to transfer the messages in ad hoc to complete a remote attestation.</li>
<li>Discussion of an order of preference for attestation methods and when the order mattered.</li>
<li>Motivation for focusing on the background check model.</li>
</ul>
</li>
<li><strong>Ad-hoc with PSK Authentication (John):</strong>
<ul>
<li>Discussion of adding a new method with PSK authentication and a new border label to derive a resumption PSK.</li>
<li>Privacy concerns with PSK authentication, including using external long-term PSK identifiers which potentially enable device tracking.</li>
<li>Requiring ephemeral Diffie-Hellman during the initial handshake.</li>
<li>Discussion of deriving a new resumption PSK for each resumption for added privacy.</li>
<li>Christam questioned how KID in the first message differed from key ID for asymmetric cases</li>
</ul>
</li>
<li><strong>disco protocol (Johan):</strong>
<ul>
<li>Showcased the disco protocol and the implementation on a constrained device.</li>
<li>The disco implementation was shown to have a fairly small footprint and good performance characteristics.</li>
<li>Suggestion of looking at ASCOM and it's quantum security levels.</li>
</ul>
</li>
</ul>
<h2>Decisions and Action Items</h2>
<ul>
<li><strong>ACTION</strong>: Participants to send a mail to the list saying yes or against working group adoption draft implementation considerations.</li>
<li><strong>ACTION</strong>: Consider the privacy implications of collecting gateway identifiers in the Lightweight Authorization using Ad-hoc draft and define more precisely what information is being communicated.</li>
<li><strong>ACTION</strong>: Revise application profiles draft and proceed to working group adoption call.</li>
<li><strong>ACTION</strong>: Continue developing remote attestation draft with consideration of the verifier role and its specification.</li>
<li><strong>ACTION</strong>: Start drafting a new method with PSK authentication and a new border label to derive a resumption PSK.</li>
</ul>
<h2>Next Steps</h2>
<ul>
<li>Continue discussion on the mailing list for open issues.</li>
<li>Incorporate feedback into draft revisions.</li>
<li>Address action items identified during the meeting.</li>
</ul>

      
    </main>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const toggle = document.querySelector('.menu-toggle');
        const menu = document.querySelector('.menu');

        toggle.addEventListener('click', function(e) {
          e.stopPropagation();
          menu.classList.toggle('show');
        });

        // Close menu when clicking outside
        document.addEventListener('click', function() {
          menu.classList.remove('show');
        });

        // Prevent menu from closing when clicking inside it
        menu.addEventListener('click', function(e) {
          e.stopPropagation();
        });
      });
    </script>
  </body>
</html>
