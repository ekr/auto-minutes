<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>IETF Meeting Minutes</title>
    <link rel="stylesheet" href="/style.css">
  </head>
  <body>
    <header class="site-header">
      <div class="header-content">
        <a href="/">
          <img src="/img/logo.jpg" alt="Logo" width="150" height="150">
        </a>
        <div class="header-text">
          <h1>Automatic IETF Minutes</h1>
          <p class="subtitle">Automatically generated minutes for IETF meetings</p>
        </div>
        <nav class="header-nav">
          <button class="menu-toggle" aria-label="Toggle menu">â˜°</button>
          <ul class="menu">
            <li><a href="/">Home</a></li>
            <li><a href="/about.html">About</a></li>
            <li><a href="https://github.com/ekr/auto-minutes">Source</a></li>
            <li><a href="/license">License</a></li>
          </ul>
        </nav>
      </div>
    </header>
    <main class="main-content">
      <p><a href="ccwg.txt">Markdown Version</a> | <a href="https://meetecho-player.ietf.org/playout/?session=IETF118-CCWG-20231107-0830">Session Recording</a></p>
<p><strong>Session Date/Time:</strong> 07 Nov 2023 08:30</p>
<h1>ccwg</h1>
<h2>Summary</h2>
<p>This CCWG meeting focused on congestion control algorithms and their evaluation. Key topics included the revision of RFC 5033 bis, discussions around real-time vs. best-effort traffic considerations, the impact of various AQMs, and the challenges of deploying congestion control algorithms in Quick. Presentations were given on safe congestion control, analysis of different congestion control schemes, and the importance of implementation conformance in Quick.</p>
<h2>Key Discussion Points</h2>
<ul>
<li>
<p><strong>RFC 5033 bis Revision:</strong></p>
<ul>
<li>The draft has been reorganized with separation of criteria and scenarios.</li>
<li>Discussion on how to handle multipath scenarios.</li>
<li>Debate on requirements for interacting with systemically important congestion controls, including those not formally specified.</li>
<li>Should consideration be given to new proposals and impact on algorithms where there are no absolute specifications?</li>
<li>The group discussed a need to consider real-time application needs and interactions when developing best-effort algorithms.</li>
<li>The social implications of congestion control behaviour were discussed, with the importance of preventing queue building for real-time traffic</li>
<li>AQM (Active Queue Management) was identified as a key component to ensure efficient capacity measurement.</li>
<li>Extensive discussion on how far new congestion controls should be evaluated with various AQMs and FIFO queues.</li>
<li>The role of AQMs in achieving consistent low delay was emphasized.</li>
<li>Evaluating new congestion control algorithms with FIFO queues was deemed necessary.</li>
</ul>
</li>
<li>
<p><strong>Safe Congestion Control Presentation (Matt):</strong></p>
<ul>
<li>The goal is to identify criteria for &quot;safe&quot; congestion control algorithms.</li>
<li>Consideration on limit of self-induced loss that a CC should be allowed to inflict.</li>
<li>Average loss and average rate should have a monotonic relationship.</li>
<li>Control period/frequency should be related to RTT, not stream performance.</li>
<li>The importance of freedom from starvation (small flows not starved by large flows).</li>
<li>Adverse conditions must not make congestion control behavior worse.</li>
</ul>
</li>
<li>
<p><strong>Analysis of Differences Between Congestion Control Schemes (Yossi):</strong></p>
<ul>
<li>Draft comparing TCP Reno, Cubic, and Quick congestion control.</li>
<li>Highlighting differences to initiate discussions and provide reference for future analysis.</li>
<li>Discussion whether TCP has one congestion control.</li>
<li>Issue about Reno and Cubic both doing things that should be banned, and comparing against them is not a good thing.</li>
</ul>
</li>
<li>
<p><strong>Cambrian Explosion in Quick Congestion Control (Ayush):</strong></p>
<ul>
<li>Motivation for deployability to be assigned to implementation rather than the algorithm itself</li>
<li>Implementations of standard CC algorithms had poor performance compared to their kernel counterpart</li>
<li>Identified significant speciation between CC implementations in Quick stacks, even for well-known algorithms.</li>
<li>The notion that it should be a consideration to attach a standard implementation to any recommendations.</li>
</ul>
</li>
</ul>
<h2>Decisions and Action Items</h2>
<ul>
<li><strong>Action Item (Eric):</strong> Capture requirement for best-effort algorithms to consider the needs and interactions with real-time applications.</li>
<li><strong>Action Item (Martin and Corey):</strong>  Capture what the group heard and summarize from the session.</li>
<li><strong>Action Item (Matt):</strong> File an issue to write something encouraging to people early in the document.</li>
<li><strong>Action Item (Magnus):</strong> File a GitHub issue regarding the scoping of multicast in the 5033 bis document.</li>
<li><strong>Issue 42:</strong> A new issue has been created to collect community input regarding self-induced loss.</li>
</ul>
<h2>Next Steps</h2>
<ul>
<li>Continue revisions to RFC 5033 bis, incorporating feedback from the meeting.</li>
<li>Address open issues in the GitHub repository.</li>
<li>Discuss potential inclusion of self-induced loss as an explicit criterion in 5033 bis.</li>
<li>Continued discussion on the mailing list and GitHub regarding various congestion control topics.</li>
<li>Further analysis on different congestion control schemes.</li>
</ul>

      
    </main>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const toggle = document.querySelector('.menu-toggle');
        const menu = document.querySelector('.menu');

        toggle.addEventListener('click', function(e) {
          e.stopPropagation();
          menu.classList.toggle('show');
        });

        // Close menu when clicking outside
        document.addEventListener('click', function() {
          menu.classList.remove('show');
        });

        // Prevent menu from closing when clicking inside it
        menu.addEventListener('click', function(e) {
          e.stopPropagation();
        });
      });
    </script>
  </body>
</html>
