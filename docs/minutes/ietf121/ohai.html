<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>IETF Meeting Minutes</title>
    <link rel="stylesheet" href="/style.css">
  </head>
  <body>
    <header class="site-header">
      <div class="header-content">
        <a href="/">
          <img src="/img/logo.jpg" alt="Logo" width="150" height="150">
        </a>
        <div class="header-text">
          <h1>Automatic IETF Minutes</h1>
          <p class="subtitle">Automatically generated minutes for IETF meetings</p>
        </div>
        <nav class="header-nav">
          <button class="menu-toggle" aria-label="Toggle menu">â˜°</button>
          <ul class="menu">
            <li><a href="/">Home</a></li>
            <li><a href="/about.html">About</a></li>
            <li><a href="https://github.com/ekr/auto-minutes">Source</a></li>
            <li><a href="/license">License</a></li>
          </ul>
        </nav>
      </div>
    </header>
    <main class="main-content">
      <p><a href="ohai.txt">Markdown Version</a> | <a href="https://meetecho-player.ietf.org/playout/?session=IETF121-OHAI-20241105-1800">Session Recording</a></p>
<p><strong>Session Date/Time:</strong> 05 Nov 2024 18:00</p>
<h1>ohai</h1>
<h2>Summary</h2>
<p>This meeting focused on the Chunked Oblivious HTTP draft. Discussions centered on the dependency on the incremental HTTP draft, security implications of incremental delivery (particularly timing attacks and replayability), and other remaining issues like negotiation, maximum chunk size, and security considerations related to interactivity. The goal is to resolve the remaining issues and solicit reviews for eventual publication.</p>
<h2>Key Discussion Points</h2>
<ul>
<li>
<p><strong>Dependency on Incremental HTTP Draft:</strong></p>
<ul>
<li>The Chunked OHDP draft introduces a dependency on the &quot;incremental HTTP&quot; draft to signal incremental delivery to intermediaries (relays).</li>
<li>Debate arose regarding whether this dependency should be normative or informational. Concerns were raised about potential changes to the incremental HTTP header format and its impact on the Chunked OHDP draft.</li>
<li>It was noted that relays often buffer requests/responses, and the incremental HTTP header provides a standard way to signal incremental delivery, which was previously accomplished by manually configuring relays.</li>
</ul>
</li>
<li>
<p><strong>Security Implications of Incremental Delivery:</strong></p>
<ul>
<li>Concerns were raised about the security implications of incremental delivery and the potential for timing attacks, especially when request and response chunks are interleaved.</li>
<li>It was suggested that interleaved request and response processing fundamentally changes the security properties of Oblivious HTTP, potentially allowing attackers to correlate requests and responses.</li>
<li>The discussion highlighted the need for clearer guidance on interactivity and the security assumptions that are violated when incremental requests and responses are combined.</li>
<li>The use of padding and normalization of timing were suggested as potential mitigation strategies for timing attacks.</li>
<li>The need for redoing the formal security analysis to account for incremental delivery was emphasized.</li>
</ul>
</li>
<li>
<p><strong>Negotiation of Chunked OHDP:</strong></p>
<ul>
<li>The discussion centered on how a client knows whether a relay and gateway support Chunked OHDP.</li>
<li>The conclusion was that the media type should be used to signal support, and if Chunked OHDP is required, the client should just try it and treat failure as a general OHDP failure.</li>
<li>It was decided that the draft should state that if chunked is used on the request, the gateway must use chunked on the response.</li>
</ul>
</li>
<li>
<p><strong>Maximum Chunk Size:</strong></p>
<ul>
<li>The group discussed the need for a minimum maximum chunk size for interoperability.</li>
<li>16KB (2^14) was proposed as a suitable default minimum maximum chunk size.</li>
</ul>
</li>
<li>
<p><strong>Media Type Registration:</strong></p>
<ul>
<li>It was suggested to explicitly ask the media type registration authority for an incantation that prevents the use of fragment identifiers with the new media type to prevent a potential source of confusion.</li>
</ul>
</li>
<li>
<p><strong>Replayability:</strong></p>
<ul>
<li>The potential for replayability attacks was discussed, and the need for more detailed text on security concerns related to interactivity was highlighted.</li>
</ul>
</li>
</ul>
<h2>Decisions and Action Items</h2>
<ul>
<li><strong>Action Item:</strong> Tommy and Martin to work on expanding the text on security concerns around interactivity and replayability.</li>
<li><strong>Action Item:</strong> Tommy to work on incorporating the media type registration suggestion.</li>
<li><strong>Action Item:</strong> Authors to finalize the draft changes based on the issues discussed.</li>
<li><strong>Decision:</strong> 16KB (2^14) will be used as the default minimum maximum chunk size.</li>
<li><strong>Decision:</strong> If chunked is used on the request, the gateway must use chunked on the response.</li>
<li><strong>Action Item:</strong> Solicit help with formal security analysis, including Jonathan Hui if available.</li>
</ul>
<h2>Next Steps</h2>
<ul>
<li>Address remaining issues and incorporate feedback from the meeting.</li>
<li>Complete test vectors.</li>
<li>Conduct more interoperability testing, including Martin's updated reference implementation.</li>
<li>Monitor the progress and stabilization of the incremental HTTP draft.</li>
<li>Once the major issues are resolved (excluding formal analysis and test vectors), solicit working group reviews.</li>
</ul>

      
    </main>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const toggle = document.querySelector('.menu-toggle');
        const menu = document.querySelector('.menu');

        toggle.addEventListener('click', function(e) {
          e.stopPropagation();
          menu.classList.toggle('show');
        });

        // Close menu when clicking outside
        document.addEventListener('click', function() {
          menu.classList.remove('show');
        });

        // Prevent menu from closing when clicking inside it
        menu.addEventListener('click', function(e) {
          e.stopPropagation();
        });
      });
    </script>
  </body>
</html>
