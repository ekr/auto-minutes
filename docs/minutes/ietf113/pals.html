<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>IETF Meeting Minutes</title>
    <link rel="stylesheet" href="/style.css">
  </head>
  <body>
    <header class="site-header">
      <div class="header-content">
        <a href="/">
          <img src="/img/logo.jpg" alt="Logo" width="150" height="150">
        </a>
        <div class="header-text">
          <h1>Automatic IETF Minutes</h1>
          <p class="subtitle">Automatically generated minutes for IETF meetings</p>
        </div>
        <nav class="header-nav">
          <button class="menu-toggle" aria-label="Toggle menu">â˜°</button>
          <ul class="menu">
            <li><a href="/">Home</a></li>
            <li><a href="/about.html">About</a></li>
            <li><a href="https://github.com/ekr/auto-minutes">Source</a></li>
            <li><a href="/license">License</a></li>
          </ul>
        </nav>
      </div>
    </header>
    <main class="main-content">
      <p><a href="pals.txt">Markdown Version</a> | <a href="https://meetecho-player.ietf.org/playout/?session=IETF113-PALS-20220324-0900">Session Recording</a></p>
<p><strong>Session Date/Time:</strong> 24 Mar 2022 09:00</p>
<h1>pals</h1>
<h2>Summary</h2>
<p>This joint meeting of the PALS, MPLS, and .NET working groups was convened to discuss architectural issues and solution proposals for new application uses at the bottom of the MPLS label stack, collectively referred to as MPLS Indicators and Ancillary Data (MIAD). The session included status reports from the Open Design Team (ODT), presentations on use cases, requirements, a framework, and multiple solution drafts proposing mechanisms for MIAD. Key discussions revolved around terminology, the need for in-stack vs. post-stack data, hardware compatibility, backward compatibility, and the process for adopting guiding documents and solution proposals.</p>
<h2>Key Discussion Points</h2>
<ul>
<li>
<p><strong>Welcome and Agenda (00:00:35 - 00:04:01)</strong></p>
<ul>
<li>Joint meeting of PALS, MPLS, and .NET to discuss architectural issues and solution proposals for new application uses at the bottom of the MPLS label stack.</li>
<li>Agenda included ODT status, use cases, requirements, framework, technical proposals, and open discussion.</li>
</ul>
</li>
<li>
<p><strong>Open Design Team (ODT) Report (Lars Eggert) (00:04:01 - 00:12:03)</strong></p>
<ul>
<li>ODT is a joint activity across PALS, MPLS, and .NET, meeting weekly with ~20 participants discussing ~20 documents.</li>
<li>The initiative, initially called &quot;MIAD&quot; (MPLS Indicator and Ancillary Data), aims to define an architecture for using the data plane to send instructions and ancillary data between LSRs.</li>
<li>Discussion around terminology: &quot;Forwarding Actions,&quot; &quot;Network Actions,&quot; &quot;MIAD Actions,&quot; or simply &quot;Actions.&quot; Preference to pick one term early.</li>
<li>Ancillary Data: Data used to perform requested actions, also sent in the packet.</li>
<li>Document Types: &quot;Guiding&quot; (requirements, framework, use cases) and &quot;Specifying&quot; (solutions).</li>
<li>Process for Progressing Documents: Desire to adopt guiding documents first, then solutions. Consensus calls across all three WGs, with discussion primarily on the MPLS list.</li>
<li>Challenges: Some proposed solutions are not compatible; ongoing discussion on the process for adoption. No consensus yet on an end-to-end discussion poll.</li>
<li>MIAD differs from traditional MPLS by using the data plane for instructions, introducing a strong dependency on hardware and optimization for coding. No strong consensus on hardware optimization yet, but nearing it.</li>
</ul>
</li>
<li>
<p><strong>Use Cases for MIAD (Tarek Saad) (00:12:03 - 00:29:56)</strong></p>
<ul>
<li>Document compiles use cases for MIAD from ODT discussions.</li>
<li>MIAD aims to address requirements from new MPLS applications by including an indicator for specific functions and optional ancillary data.</li>
<li>Ancillary data is added by ingress LER, may be updated by transit LSRs, and removed by egress LER.</li>
<li><strong>Use Cases Presented:</strong>
<ul>
<li><strong>No Further Reroute</strong>: Indicator to prevent looping in FRR scenarios by disallowing further reroutes.</li>
<li><strong>In-situ OAM (iOAM)</strong>: Carry telemetry/operational data within user traffic, requiring a function indicator to alert nodes for processing.</li>
<li><strong>Network Slicing</strong>: Identify packets belonging to specific Network Resource Partitions (NRPs) to apply per-hop behavior using a resource selector indicator.</li>
<li><strong>Time-Sensitive Networking (TSN)</strong>: Carry a timestamp or time budget for queuing decisions; requires engagement with the TSN WG.</li>
<li><strong>Network Programming</strong>: Similar to SRv6, carry a packet processing program/sequence of instructions in MPLS packets as a function indicator with arguments as ancillary data.</li>
<li><strong>Service Function Chaining (SFC)</strong>: Investigate carrying NSH as ancillary data, potentially superior to emulating NSH in the label stack.</li>
</ul>
</li>
<li>Next steps: Welcome operator engagement and further input to the document.</li>
<li><strong>Discussion</strong>: Question if &quot;Network Programming&quot; (use case #5) could be an overarching mechanism covering other use cases. Tarek clarified MIAD is generic, and #5 is an aspiration requiring WG interest.</li>
</ul>
</li>
<li>
<p><strong>MIAD Requirements Draft (Matthew Bocci) (00:30:02 - 00:48:01)</strong></p>
<ul>
<li>Document captures key requirements for ancillary data and indicators, an output of the ODT.</li>
<li><strong>Key Terminology Defined:</strong>
<ul>
<li><strong>Ancillary Data</strong>: Data affecting forwarding/processing, can be &quot;in-stack&quot; or &quot;post-stack.&quot;</li>
<li><strong>Ancillary Data Indicator (ADI)</strong>: Indicator in the MPLS label stack that ancillary data exists, its type, and how to process it.</li>
</ul>
</li>
<li><strong>General Requirements</strong>: Maintain MPLS extensibility, flexibility, and efficiency (RFC 3031/3032 consistency). Solutions must not restrict generality, use existing MPLS mechanisms where possible, ensure efficient label stack parsing, and minimize label stack depth.</li>
<li><strong>Requirements on ADI</strong>: Need for ADI, coexistence with existing MPLS, head-end knowledge of insertion, support for end-to-end/hop-by-hop processing.</li>
<li><strong>Requirements on Ancillary Data</strong>: Coexistence with MPLS/post-stack mechanisms (control words/ACHs), protocol efficiency (not too deep in packet), processing impact (fast vs. slow path), scope (control, maintenance, user traffic), and security (authenticity, confidentiality).</li>
<li>Status: Draft is mature, needs editorial cleanup, ready for MPLS WG adoption.</li>
<li><strong>Discussion</strong>:
<ul>
<li>Concern about limiting in-stack data size; the FAI document (Kirti's) suggests 4-8 octets and justification for in-stack placement.</li>
<li>Hardware limitations (e.g., Broadcom chips with 3-label depth); discussion on reusing label bits (TC/TTL) vs. new labels.</li>
<li>Need for clear signaling (e.g., via IGPs/BGP-LS) to indicate node capabilities to avoid imposing unreadable data.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Framework Draft (Lars Eggert) (00:48:01 - 00:54:33)</strong></p>
<ul>
<li>Distinction: Framework (interworking with environment) vs. Architecture (internal workings).</li>
<li>Status: Initial version received positive comments but requires significant work. John Drake, Tony Lee, and Adrian Farrel have contributed text.</li>
<li>Next Steps: Tony Lee will take over editing. A new version will be posted after careful review by ODT and WGs, aiming to converge on terminology. Expected to be ready for WG adoption soon.</li>
</ul>
</li>
<li>
<p><strong>Solution: MPLS Extension Header Encoding (Jags) (00:54:33 - 01:18:22)</strong></p>
<ul>
<li>Proposal for a generic framework to encode MPLS extension headers, carrying multiple forwarding instructions.</li>
<li>Supports flag-based instructions (no ancillary data) and instructions needing ancillary data. Allows in-stack, post-stack, and their coexistence. Backward compatibility is a goal.</li>
<li>Hardware analysis performed.</li>
<li><strong>Extension Header Indicator Options:</strong>
<ol>
<li>Extend existing ELI/EL by repurposing TC and TTL.</li>
<li>Assign a new Special Purpose Label (SPL).</li>
<li>Use a user-configured label.</li>
</ol>
</li>
<li>Proposed <strong>In-Stack Encoding</strong>: Includes a 3-bit length field (for 4-byte words), presence indicators (in-stack, post-stack, hop-by-hop post-stack), an 8-bit opcode for forwarding instruction, and ancillary data. Control bits (D, E) for data stacking and end-to-end/hop-by-hop processing.</li>
<li>Opcode values: 1 for flag-based, 2 for byte offset of post-stack data, 3-254 for IANA assignment, 255 for extension.</li>
<li>Proposed <strong>Post-Stack Encoding</strong>: Indicators for presence and hop-by-hop processing. A generic format with a fixed zero-nibble, reserved label, 8-bit opcode, length, and flags (next header, hop-by-hop).</li>
<li>Examples provided for various scenarios.</li>
<li>Comparison: Option 1 (reusing ELI/EL) might lead to shorter stack depth (5 vs. 7 labels for option 2).</li>
<li>Request for WG adoption and feedback on indicator options.</li>
<li><strong>Discussion</strong>: Concerns about multiple indicators and the <code>E</code> (end-to-end) bit meaning per instruction. Issue with older nodes popping ELI and exposing data, requiring all nodes to support new ELI interpretation. Comparison with other published documents on extension headers and post-stack data.</li>
</ul>
</li>
<li>
<p><strong>Solution: Entropy Label Control Field Extension (Bruno Decraene) (01:18:22 - 01:28:44)</strong></p>
<ul>
<li>Proposal to extend the existing Entropy Label (EL) by redefining its TTL field as an 8-bit &quot;Entropy Label Control Field&quot; (ELCF).</li>
<li>The 8 flags are proposed to be user-defined to maximize reusability.</li>
<li><strong>Benefits</strong>:
<ul>
<li>Faster deployment: Most existing egress LSRs already support ELI, so they won't drop packets. Incremental deployment possible.</li>
<li>Minimizes label stack: Adds indicators without extra labels, especially when load balancing is needed.</li>
<li>Leverages existing SPL and signaling.</li>
</ul>
</li>
<li>Use cases include E2E loss measurement and slice ID.</li>
<li>Status: Individual draft since Dec 2020, presented multiple times, requesting call for adoption in MPLS WG.</li>
<li><strong>Discussion</strong>:
<ul>
<li>Relationship to Jags' proposal: Bruno's is seen as independent, providing a specific mechanism for indicators.</li>
<li>Limited number of indicators (8-11 bits) vs. perceived needs. Bruno argues 8 is a good start, extensible if needed.</li>
<li>Strong advantage of backward compatibility for legacy nodes.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Solution: Forwarding Actions Indicator (FAI) (Kirti Purbhoo) (01:28:44 - 01:43:59)</strong></p>
<ul>
<li>Draft is functionally stable, focusing on bit wrangling, backward compatibility, extensibility, IANA details, and deployment strategies.</li>
<li><strong>Key Contributions</strong>:
<ul>
<li>Single SPL for multiple purposes, addressing SPL exhaustion.</li>
<li>Uses full label entry (including TC and TTL).</li>
<li>Encodes forwarding actions very succinctly for efficiency.</li>
</ul>
</li>
<li><strong>Questions for Working Group Consensus (to be discussed on mailing list/survey):</strong>
<ol>
<li><strong>Value of In-Stack Data</strong>: Should in-stack data be allowed? Authors' opinion: Yes, for critical/efficient forwarding, with guidelines on what, when, and how big.</li>
<li><strong>Repeating In-Stack Data in Post-Stack</strong>: Should in-stack data be repeated in post-stack? Authors' opinion: No, risk of conflict.</li>
<li><strong>Efficiency and Extensibility</strong>: Is the approach of encoding actions as single bits (with bit position defining action), using an IANA registry for associated data length, and extensible flag bits (via additional LSEs) acceptable? Authors' opinion: Yes, efficient and extensible, supported by hardware experts.</li>
<li><strong>Two-Bit Flag for EL/Slice ID</strong>: Is the flexibility of a 2-bit flag for combined Entropy Label and Slice ID useful, despite potential complexity? Authors' opinion: Yes, allows flexibility and often uses one LSE instead of two.</li>
<li><strong>SPL Reaching Top of Stack</strong>: Should the FAI SPL be allowed to reach the top of stack? Options: Never allow, allow with signaling, or push a neutral label (e.g., label 0).</li>
</ol>
</li>
<li>Next steps: Editorial cleanup, IANA section, procedures. Request for WG adoption, not contingent on resolving all details.</li>
<li><strong>Discussion</strong>: Suggested an electronic survey for the questions. Concern about encoding that requires &quot;bouncing around&quot; in the packet for associated data, although implementers report it's manageable.</li>
</ul>
</li>
<li>
<p><strong>IANA Registry for Post-Stack First Nibble (Kirti Purbhoo) (01:43:59 - 01:49:28)</strong></p>
<ul>
<li>Proposal for an IANA registry for the first nibble <em>after</em> the bottom of the label stack.</li>
<li>Clarifies that the first nibble is <em>not</em> an IP version number and all 16 values (except 4 and 6, due to legacy hacks) can be used.</li>
<li><strong>Requirement</strong>: If not an IP packet, a post-stack header (e.g., Control Word) <em>must</em> be used. This strengthens RFC 4928.</li>
<li><strong>Recommendation</strong>: For load balancing, <em>do not</em> use the hack of guessing IP based on the first nibble (i.e., use an entropy label).</li>
<li><strong>Discussion</strong>: This addresses issues with guessing packet types based on the first nibble, which can cause problems for load balancing and application-aware routing.</li>
</ul>
</li>
</ul>
<h2>Decisions and Action Items</h2>
<ul>
<li><strong>Decision</strong>: The meeting concluded without a consensus on which solution draft(s) to adopt, or the preferred architectural approach. Multiple drafts are requesting Working Group adoption, highlighting the need for further discussion and resolution within the ODT and respective Working Groups.</li>
<li><strong>Action Item</strong>: The chairs will consider setting up an electronic survey to gather consolidated feedback on the specific questions raised by Kirti Purbhoo's FAI draft (and potentially other key architectural questions) from the community.</li>
<li><strong>Action Item</strong>: Tony Lee will take over as the primary editor for the Framework draft to progress it towards a new version and eventual Working Group adoption.</li>
<li><strong>Action Item</strong>: All architectural and solution proposals will continue to be discussed on the respective mailing lists, with a particular focus on addressing the backward compatibility, hardware implementation, and deployment concerns raised.</li>
</ul>
<h2>Next Steps</h2>
<ul>
<li><strong>Working Group Adoption</strong>: Calls for adoption are anticipated for the Requirements, Framework, and several Solution drafts in the MPLS WG and potentially PALS/.NET.</li>
<li><strong>Terminology Convergence</strong>: Continued effort to converge on a unified terminology across all MIAD-related drafts.</li>
<li><strong>Deployment Considerations</strong>: Detailed analysis and discussion are needed on hardware compatibility, backward compatibility with legacy devices, and practical deployment strategies for the proposed solutions.</li>
<li><strong>Use Case Validation</strong>: Further investigation and community engagement (e.g., with TSN WG) to validate and refine the compiled use cases.</li>
<li><strong>Mailing List Discussion</strong>: Further technical discussions on the various proposals, particularly the fundamental architectural choices (e.g., in-stack vs. post-stack data, specific indicator mechanisms), will continue on the working group mailing lists.</li>
</ul>

      
    </main>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const toggle = document.querySelector('.menu-toggle');
        const menu = document.querySelector('.menu');

        toggle.addEventListener('click', function(e) {
          e.stopPropagation();
          menu.classList.toggle('show');
        });

        // Close menu when clicking outside
        document.addEventListener('click', function() {
          menu.classList.remove('show');
        });

        // Prevent menu from closing when clicking inside it
        menu.addEventListener('click', function(e) {
          e.stopPropagation();
        });
      });
    </script>
  </body>
</html>
