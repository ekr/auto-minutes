<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>IETF Meeting Minutes</title>
    <link rel="stylesheet" href="/style.css">
  </head>
  <body>
    <header class="site-header">
      <div class="header-content">
        <a href="/">
          <img src="/img/logo.jpg" alt="Logo" width="150" height="150">
        </a>
        <div class="header-text">
          <h1>Automatic IETF Minutes</h1>
          <p class="subtitle">Automatically generated minutes for IETF meetings</p>
        </div>
        <nav class="header-nav">
          <button class="menu-toggle" aria-label="Toggle menu">â˜°</button>
          <ul class="menu">
            <li><a href="/">Home</a></li>
            <li><a href="/about.html">About</a></li>
            <li><a href="https://github.com/ekr/auto-minutes">Source</a></li>
            <li><a href="/license">License</a></li>
          </ul>
        </nav>
      </div>
    </header>
    <main class="main-content">
      <p><a href="avtcore.txt">Markdown Version</a> | <a href="https://meetecho-player.ietf.org/playout/?session=IETF123-AVTCORE-20250722-1500">Session Recording</a></p>
<p><strong>Session Date/Time:</strong> 22 Jul 2025 15:00</p>
<h1>avtcore</h1>
<h2>Summary</h2>
<p>This AVTcore working group session covered several topics, including updates on existing drafts, discussions on new proposals, and calls for adoption. Key discussions revolved around RTP over QUIC, RTP payload formats for avatars and APV, and RTCP messages for temporal spatial resolution. The group decided to call for adoption of the APV payload format draft.</p>
<h2>Key Discussion Points</h2>
<ul>
<li><strong>STP Offer/Answer for RTP over QUIC:</strong> Discussion focused on bundle and rock flow IDs, handling of RTCP, and ICE considerations. There was debate on whether to make Rock a first-class RTP transport and how to handle fallback mechanisms.</li>
<li><strong>RTP Payload Format for Avatars:</strong> The presenter introduced a new draft for transmitting avatar-related information efficiently. Discussions focused on the size and transport properties of the data, and the assumption that meshes are already communicated out of band.</li>
<li><strong>RTP Frame Acknowledgments:</strong> The presenter discussed issues and proposed solutions related to identifying frames for acknowledgment, particularly in multi-way conferencing scenarios.</li>
<li><strong>RTP Payload Format for APV:</strong> The presenter provided updates on the APV codec and its RTP payload format, noting its stability and multiple implementations.</li>
<li><strong>RTCP Messages for Temporal Spatial Resolution:</strong> Discussions covered past concerns, recent updates, and the need for more review from RTP experts before another last call.</li>
</ul>
<h2>Decisions and Action Items</h2>
<ul>
<li><strong>RTP over QUIC:</strong> Spencer Dawkins to rework PR based on discussion regarding bundle and rock.</li>
<li><strong>RTP over QUIC:</strong> Harold Alvestrand to review the newly created issue about the multiplexing issue in the RTP over QUIC draft.</li>
<li><strong>RTP Payload Format for APV:</strong> The working group agreed to call for adoption.</li>
<li><strong>RTCP Messages for Temporal Spatial Resolution:</strong> Eric Rescorla and John Kwan volunteered to review the draft from an RTP perspective and provide feedback on the list.</li>
<li><strong>Action:</strong> Chairs to send out a doodle poll to schedule the interim meeting in September.</li>
</ul>
<h2>Next Steps</h2>
<ul>
<li>Spencer Dawkins will address the issues raised regarding RTP over QUIC and prepare a revised draft for adoption.</li>
<li>The Chairs will initiate a call for adoption for the RTP payload format for APV.</li>
<li>Eric Rescorla and John Kwan will review the RTCP messages for temporal spatial resolution draft.</li>
<li>The chairs will schedule an interim meeting in September.</li>
</ul>

      
    </main>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const toggle = document.querySelector('.menu-toggle');
        const menu = document.querySelector('.menu');

        toggle.addEventListener('click', function(e) {
          e.stopPropagation();
          menu.classList.toggle('show');
        });

        // Close menu when clicking outside
        document.addEventListener('click', function() {
          menu.classList.remove('show');
        });

        // Prevent menu from closing when clicking inside it
        menu.addEventListener('click', function(e) {
          e.stopPropagation();
        });
      });
    </script>
  </body>
</html>
