<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>IETF Meeting Minutes</title>
    <link rel="stylesheet" href="/style.css">
  </head>
  <body>
    <header class="site-header">
      <div class="header-content">
        <a href="/">
          <img src="/img/logo.jpg" alt="Logo" width="150" height="150">
        </a>
        <div class="header-text">
          <h1>Automatic IETF Minutes</h1>
          <p class="subtitle">Automatically generated minutes for IETF meetings</p>
        </div>
        <nav class="header-nav">
          <button class="menu-toggle" aria-label="Toggle menu">â˜°</button>
          <ul class="menu">
            <li><a href="/">Home</a></li>
            <li><a href="/about.html">About</a></li>
            <li><a href="https://github.com/ekr/auto-minutes">Source</a></li>
            <li><a href="/license">License</a></li>
          </ul>
        </nav>
      </div>
    </header>
    <main class="main-content">
      <p><a href="iccrg.txt">Markdown Version</a> | <a href="https://meetecho-player.ietf.org/playout/?session=IETF123-ICCRG-20250721-1500">Session Recording</a></p>
<p><strong>Session Date/Time:</strong> 21 Jul 2025 15:00</p>
<h1>iccrg Meeting Minutes</h1>
<h2>Summary</h2>
<p>This session focused on congestion control research, including deployment experiences, pacing protocols, and advancements in video streaming. Presentations covered Comcast's dual queue low latency deployment, an update on a pacing protocol draft, and research on burstiness control for real-time video streaming. A significant portion of the meeting involved a panel discussion about integrating adaptive streaming algorithms and congestion control mechanisms.</p>
<h2>Key Discussion Points</h2>
<ul>
<li><strong>Comcast's Dual Queue Deployment:</strong> Discussed the impact of deploying dual queue low latency (L4S and NQB) and active queue management (AQM) on bandwidth tests and user experience.  Key findings included improved working latency but challenges with synthetic bandwidth tests. The need to adjust test parameters and communicate changes to operations teams was emphasized.</li>
<li><strong>Pacing Protocol Draft:</strong>  An update was presented on the draft documenting pacing techniques, their pros and cons, and existing implementations. Strong interest in adoption was expressed.</li>
<li><strong>Burstiness Control for Real-Time Video Streaming:</strong> Research was shared on the effect of pacing on video streaming, particularly concerning latency. A solution involving adaptive token bucket pacing and dynamic encoding complexity was presented.</li>
<li><strong>Integration of Adaptive Streaming and Congestion Control:</strong> Panel discussion highlighted the benefits of combining adaptive streaming algorithms (ABR) and congestion control. Netflix shared their experience with application-informed pacing, aiming to reduce burstiness and improve co-existing traffic performance.  The discussion included standardization needs of API signals between ABR and condition control. The necessity of finer-grained APIs was discussed to address the lack of information between the application and transport layers.</li>
</ul>
<h2>Decisions and Action Items</h2>
<ul>
<li><strong>Pacing Protocol Draft Adoption:</strong> The group expressed support for adopting the pacing protocol draft. A formal adoption call will be announced on the mailing list.</li>
<li><strong>Application/Transport Layer Signal Standardization:</strong> Action item to continue discussing potential standardization of application/transport layer interfaces for congestion control on the mailing list.</li>
</ul>
<h2>Next Steps</h2>
<ul>
<li>Follow up on the mailing list regarding the pacing protocol draft adoption.</li>
<li>Continue discussion on standardizing application/transport layer interfaces for congestion control on the mailing list, focusing on documenting the signal and interface opportunities.</li>
</ul>

      
    </main>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const toggle = document.querySelector('.menu-toggle');
        const menu = document.querySelector('.menu');

        toggle.addEventListener('click', function(e) {
          e.stopPropagation();
          menu.classList.toggle('show');
        });

        // Close menu when clicking outside
        document.addEventListener('click', function() {
          menu.classList.remove('show');
        });

        // Prevent menu from closing when clicking inside it
        menu.addEventListener('click', function(e) {
          e.stopPropagation();
        });
      });
    </script>
  </body>
</html>
