<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>IETF Meeting Minutes</title>
    <link rel="stylesheet" href="/style.css">
  </head>
  <body>
    <header class="site-header">
      <div class="header-content">
        <a href="/">
          <img src="/img/logo.jpg" alt="Logo" width="150" height="150">
        </a>
        <div class="header-text">
          <h1>Automatic IETF Minutes</h1>
          <p class="subtitle">Automatically generated minutes for IETF meetings</p>
        </div>
        <nav class="header-nav">
          <button class="menu-toggle" aria-label="Toggle menu">â˜°</button>
          <ul class="menu">
            <li><a href="/">Home</a></li>
            <li><a href="/about.html">About</a></li>
            <li><a href="https://github.com/ekr/auto-minutes">Source</a></li>
            <li><a href="/license">License</a></li>
          </ul>
        </nav>
      </div>
    </header>
    <main class="main-content">
      <p><a href="savnet.txt">Markdown Version</a> | <a href="https://meetecho-player.ietf.org/playout/?session=IETF117-SAVNET-20230727-2000">Session Recording</a></p>
<p><strong>Session Date/Time:</strong> 27 Jul 2023 20:00</p>
<h1>savnet</h1>
<h2>Summary</h2>
<p>The savnet working group meeting focused on source address validation (SAV) architectures and related work. Discussions covered problem statements, architecture drafts (intra-domain and inter-domain), table size analysis, open-source implementation efforts, and YANG modeling. Key topics included the accuracy of SAV information, convergence issues, incremental deployment, security considerations, and the design of SAV-specific messages.</p>
<h2>Key Discussion Points</h2>
<ul>
<li><strong>Problem Statement Accuracy and Convergence:</strong> The working group discussed the need for accuracy in SAV mechanisms, focusing on minimizing false positives and false negatives. Convergence was also a key concern, specifically the potential for race conditions if SAV information and routing information converge at different rates. The group debated whether to prioritize allowing potentially invalid traffic during convergence or err on the side of dropping traffic, causing temporary black holes.</li>
<li><strong>SAV Information Propagation:</strong> There was considerable discussion on how SAV information should be propagated, whether using existing routing protocols or a new SAV-specific protocol. There was debate on whether SAV should propagate the <em>location</em> of authorized sources or the actual <em>forwarding path.</em> The discussion raised questions about the size of SAV tables and how to minimize their impact on router resources.</li>
<li><strong>Incremental Deployment:</strong> Participants emphasized the importance of supporting incremental and partial deployment of SAV mechanisms. The discussion considered how to use existing information (e.g., routing information, RPKI) when SAV-specific information is not yet available. The working group recognized the need to differentiate between incremental deployment of SAV protocol support and incremental deployment of acting on the SAV information.</li>
<li><strong>Architecture Draft Updates:</strong> Presenters provided updates on intra-domain and inter-domain SAV architecture drafts, highlighting revisions based on previous IETF meeting feedback. These included clarifications on terminology, additions of management considerations, and expansions of security considerations sections.</li>
<li><strong>Table Size Analysis:</strong> An analysis of SAV table size using real-world data was presented. It compared the size of forwarding information bases (FIBs) with SAV tables under different validation modes. The analysis suggested that interface-level SAV modes resulted in smaller tables than FIBs, while AS-level SAV modes could result in larger tables. The presentation then went on to discuss the impact that prefix aggregation has on table size.</li>
<li><strong>Open Source Implementation:</strong> An update on the &quot;Open Playground&quot; (SAL OP) project, an open-source tool for building and emulating network topologies to test SAV mechanisms, was given. The relationship of this implementation with the broader goals of the working group was discussed.</li>
<li><strong>YANG Model:</strong> An initial YANG model for SAV was presented, providing a framework for configuring and managing SAV subsystems. Participants acknowledged that the model was preliminary and would likely undergo significant changes as the working group's understanding of SAV requirements evolved.</li>
</ul>
<h2>Decisions and Action Items</h2>
<ul>
<li><strong>Action Item:</strong> Jeff Haas will send a note to the list highlighting the need to expand on the existing discussion of convergence in the requirements documents.</li>
<li><strong>Action Item:</strong> Authors of the architecture drafts will consider how to incorporate discussion of the incremental deployment of both the mechanisms to distribute SAV information and also of enforcement itself.</li>
<li><strong>Action Item:</strong> Authors of the architecture drafts to include more detail about what the content of the messages being transmitted will be.</li>
</ul>
<h2>Next Steps</h2>
<ul>
<li>Continue discussion of the problem statement and architecture drafts on the mailing list.</li>
<li>Refine the architecture drafts based on feedback from the working group.</li>
<li>Further investigate and refine the SAV table size analysis, considering prefix aggregation and the impact of path hiding.</li>
<li>Continue development and evaluation of the Open Playground (SAL OP) project.</li>
<li>Advance the YANG model based on evolving SAV requirements.</li>
</ul>

      
    </main>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const toggle = document.querySelector('.menu-toggle');
        const menu = document.querySelector('.menu');

        toggle.addEventListener('click', function(e) {
          e.stopPropagation();
          menu.classList.toggle('show');
        });

        // Close menu when clicking outside
        document.addEventListener('click', function() {
          menu.classList.remove('show');
        });

        // Prevent menu from closing when clicking inside it
        menu.addEventListener('click', function(e) {
          e.stopPropagation();
        });
      });
    </script>
  </body>
</html>
