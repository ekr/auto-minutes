<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>IETF Meeting Minutes</title>
    <link rel="stylesheet" href="/style.css">
  </head>
  <body>
    <header class="site-header">
      <div class="header-content">
        <a href="/">
          <img src="/img/logo.jpg" alt="Logo" width="150" height="150">
        </a>
        <div class="header-text">
          <h1>Automatic IETF Minutes</h1>
          <p class="subtitle">Automatically generated minutes for IETF meetings</p>
        </div>
        <nav class="header-nav">
          <button class="menu-toggle" aria-label="Toggle menu">â˜°</button>
          <ul class="menu">
            <li><a href="/">Home</a></li>
            <li><a href="/about.html">About</a></li>
            <li><a href="https://github.com/ekr/auto-minutes">Source</a></li>
            <li><a href="/license">License</a></li>
          </ul>
        </nav>
      </div>
    </header>
    <main class="main-content">
      <p><a href="ohai.txt">Markdown Version</a> | <a href="https://meetecho-player.ietf.org/playout/?session=IETF117-OHAI-20230728-1900">Session Recording</a></p>
<p><strong>Session Date/Time:</strong> 28 Jul 2023 19:00</p>
<h1>ohai</h1>
<h2>Summary</h2>
<p>The ohai working group met to discuss the status of existing drafts and a new proposal from Tommy Pauly on adding streaming capabilities to oblivious HTTP (OHAI). The discussion focused on the use cases for streaming OHAI, security implications, and potential alternatives like MASQUE. The group provided feedback on the proposal and the next steps involve creating a 00 draft and further discussion on the mailing list.</p>
<h2>Key Discussion Points</h2>
<ul>
<li><strong>Status of Working Group Drafts:</strong>
<ul>
<li>The main protocol draft was pulled back from the RFC editor queue due to a late-breaking change and has been resubmitted.</li>
<li>The SVCB config draft has been submitted for publication.</li>
<li>A call for adoption will be made for the &quot;OHAI the feedback to proxy&quot; draft.</li>
</ul>
</li>
<li><strong>Streaming OHAI Proposal (Tommy Pauly):</strong>
<ul>
<li>Current OHAI uses single messages in each direction, encrypted and decrypted in a single chunk.</li>
<li>The proposal aims to add streaming capabilities, allowing for longer messages, interactive workflows, and processing in multiple parts.</li>
<li>Key changes needed: cryptographic mechanisms for chunk encapsulation, request/response format, and a new media type.</li>
<li>Security implications were discussed, particularly regarding statefulness, correlation, and the lack of forward secrecy.</li>
<li>Use cases were questioned; the importance of clearly defining use cases that retain the lack of correlation property was emphasized.</li>
<li>Potential benefits and drawbacks compared to using MASQUE were discussed, especially regarding performance.</li>
<li>Ensuring all chunks arrive at the same server instance was identified as an operational consideration.</li>
<li>The need for guidance on when to use OHAI vs. TLS was highlighted.</li>
<li>Concerns about back pressure and rate control were raised.</li>
</ul>
</li>
<li><strong>Forward Secrecy:</strong> The possibility of enabling forward secrecy in OHAI by rapidly updating gateway public keys was briefly discussed.</li>
</ul>
<h2>Decisions and Action Items</h2>
<ul>
<li><strong>Action Item:</strong> Tommy Pauly will create a 00 draft of the streaming OHAI proposal, incorporating the feedback received during the meeting.</li>
<li><strong>Action Item:</strong> The chairs will make a call for adoption for the &quot;OHAI the feedback to proxy&quot; draft.</li>
</ul>
<h2>Next Steps</h2>
<ul>
<li>Tommy Pauly will circulate the 00 draft of the streaming OHAI proposal.</li>
<li>Further discussion on use cases, security considerations, and design choices will continue on the mailing list.</li>
<li>The working group will assess interest in adopting the &quot;OHAI the feedback to proxy&quot; draft.</li>
</ul>

      
    </main>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const toggle = document.querySelector('.menu-toggle');
        const menu = document.querySelector('.menu');

        toggle.addEventListener('click', function(e) {
          e.stopPropagation();
          menu.classList.toggle('show');
        });

        // Close menu when clicking outside
        document.addEventListener('click', function() {
          menu.classList.remove('show');
        });

        // Prevent menu from closing when clicking inside it
        menu.addEventListener('click', function(e) {
          e.stopPropagation();
        });
      });
    </script>
  </body>
</html>
